{"ast":null,"code":"const mytext = `struct group_info init_groups = { .usage = ATOMIC_INIT(2) };\n\n\n\nstruct group_info *groups_alloc(int gidsetsize){\n\n\n\n    struct group_info *group_info;\n\n\n\n    int nblocks;\n\n\n\n    int i;\n\n\n\n\n\n\n\n    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK;\n\n\n\n    /* Make sure we always allocate at least one indirect block pointer */\n\n\n\n    nblocks = nblocks ? : 1;\n\n\n\n    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER);\n\n\n\n    if (!group_info)\n\n\n\n        return NULL;\n\n\n\n    group_info->ngroups = gidsetsize;\n\n\n\n    group_info->nblocks = nblocks;\n\n\n\n    atomic_set(&group_info->usage, 1);\n\n\n\n\n\n\n\n    if (gidsetsize <= NGROUPS_SMALL)\n\n\n\n        group_info->blocks[0] = group_info->small_block;\n\n\n\n    else {\n\n\n\n        for (i = 0; i < nblocks; i++) {\n\n\n\n            gid_t *b;\n\n\n\n            b = (void *)__get_free_page(GFP_USER);\n\n\n\n            if (!b)\n\n\n\n                goto out_undo_partial_alloc;\n\n\n\n            group_info->blocks[i] = b;\n\n\n\n        }\n\n\n\n    }\n\n\n\n    return group_info;\n\n\n\n\n\n\n\nout_undo_partial_alloc:\n\n\n\n    while (--i >= 0) {\n\n\n\n        free_page((unsigned long)group_info->blocks[i]);\n\n\n\n    }\n\n\n\n    kfree(group_info);\n\n\n\n    return NULL;\n\n\n\n}\n\n\n\n\n\n\n\nEXPORT_SYMBOL(groups_alloc);\n\n\n\n\n\n\n\nvoid groups_free(struct group_info *group_info)\n\n\n\n{\n\n\n\n    if (group_info->blocks[0] != group_info->small_block) {\n\n\n\n        int i;\n\n\n\n        for (i = 0; i < group_info->nblocks; i++)\n\n\n\n            free_page((unsigned long)group_info->blocks[i]);\n\n\n\n    }\n\n\n\n    kfree(group_info);\n\n\n\n}\n\n\n\n\n\n\n\nEXPORT_SYMBOL(groups_free);\n\n\n\n\n\n\n\n/* export the group_info to a user-space array */\n\n\n\nstatic int groups_to_user(gid_t __user *grouplist,\n\n\n\n              const struct group_info *group_info)\n\n\n\n{\n\n\n\n    int i;\n\n\n\n    unsigned int count = group_info->ngroups;\n\n\n\n\n\n\n\n    for (i = 0; i < group_info->nblocks; i++) {\n\n\n\n        unsigned int cp_count = min(NGROUPS_PER_BLOCK, count);\n\n\n\n        unsigned int len = cp_count * sizeof(*grouplist);\n\n\n\n\n\n\n\n        if (copy_to_user(grouplist, group_info->blocks[i], len))\n\n\n\n            return -EFAULT;\n\n\n\n\n\n\n\n        grouplist += NGROUPS_PER_BLOCK;\n\n\n\n        count -= cp_count;\n\n\n\n    }\n\n\n\n    return 0;\n\n\n\n}\n\n\n\n\n\n\n\n/* fill a group_info from a user-space array - it must be allocated already */\n\n\n\nstatic int groups_from_user(struct group_info *group_info,\n\n\n\n    gid_t __user *grouplist)\n\n\n\n{\n\n\n\n    int i;\n\n\n\n    unsigned int count = group_info->ngroups;\n\n\n\n\n\n\n\n    for (i = 0; i < group_info->nblocks; i++) {\n\n\n\n        unsigned int cp_count = min(NGROUPS_PER_BLOCK, count);\n\n\n\n        unsigned int len = cp_count * sizeof(*grouplist);\n\n\n\n\n\n\n\n        if (copy_from_user(group_info->blocks[i], grouplist, len))\n\n\n\n            return -EFAULT;\n\n\n\n\n\n\n\n        grouplist += NGROUPS_PER_BLOCK;\n\n\n\n        count -= cp_count;\n\n\n\n    }\n\n\n\n    return 0;\n\n\n\n}\n\n\n\n\n\n\n\n/* a simple Shell sort */\n\n\n\nstatic void groups_sort(struct group_info *group_info)\n\n\n\n{\n\n\n\n    int base, max, stride;`;\nexport default mytext;","map":{"version":3,"sources":["D:/ita-2019-react/New folder (2)/game-app/src/hackertyper/text.js"],"names":["mytext"],"mappings":"AAAA,MAAMA,MAAM,GAAI;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2BAAhB;AA0XA,eAAeA,MAAf","sourcesContent":["const mytext = `struct group_info init_groups = { .usage = ATOMIC_INIT(2) };\r\n\r\n\r\n\r\nstruct group_info *groups_alloc(int gidsetsize){\r\n\r\n\r\n\r\n    struct group_info *group_info;\r\n\r\n\r\n\r\n    int nblocks;\r\n\r\n\r\n\r\n    int i;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK;\r\n\r\n\r\n\r\n    /* Make sure we always allocate at least one indirect block pointer */\r\n\r\n\r\n\r\n    nblocks = nblocks ? : 1;\r\n\r\n\r\n\r\n    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER);\r\n\r\n\r\n\r\n    if (!group_info)\r\n\r\n\r\n\r\n        return NULL;\r\n\r\n\r\n\r\n    group_info->ngroups = gidsetsize;\r\n\r\n\r\n\r\n    group_info->nblocks = nblocks;\r\n\r\n\r\n\r\n    atomic_set(&group_info->usage, 1);\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    if (gidsetsize <= NGROUPS_SMALL)\r\n\r\n\r\n\r\n        group_info->blocks[0] = group_info->small_block;\r\n\r\n\r\n\r\n    else {\r\n\r\n\r\n\r\n        for (i = 0; i < nblocks; i++) {\r\n\r\n\r\n\r\n            gid_t *b;\r\n\r\n\r\n\r\n            b = (void *)__get_free_page(GFP_USER);\r\n\r\n\r\n\r\n            if (!b)\r\n\r\n\r\n\r\n                goto out_undo_partial_alloc;\r\n\r\n\r\n\r\n            group_info->blocks[i] = b;\r\n\r\n\r\n\r\n        }\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    return group_info;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nout_undo_partial_alloc:\r\n\r\n\r\n\r\n    while (--i >= 0) {\r\n\r\n\r\n\r\n        free_page((unsigned long)group_info->blocks[i]);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    kfree(group_info);\r\n\r\n\r\n\r\n    return NULL;\r\n\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nEXPORT_SYMBOL(groups_alloc);\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nvoid groups_free(struct group_info *group_info)\r\n\r\n\r\n\r\n{\r\n\r\n\r\n\r\n    if (group_info->blocks[0] != group_info->small_block) {\r\n\r\n\r\n\r\n        int i;\r\n\r\n\r\n\r\n        for (i = 0; i < group_info->nblocks; i++)\r\n\r\n\r\n\r\n            free_page((unsigned long)group_info->blocks[i]);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    kfree(group_info);\r\n\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nEXPORT_SYMBOL(groups_free);\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/* export the group_info to a user-space array */\r\n\r\n\r\n\r\nstatic int groups_to_user(gid_t __user *grouplist,\r\n\r\n\r\n\r\n              const struct group_info *group_info)\r\n\r\n\r\n\r\n{\r\n\r\n\r\n\r\n    int i;\r\n\r\n\r\n\r\n    unsigned int count = group_info->ngroups;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    for (i = 0; i < group_info->nblocks; i++) {\r\n\r\n\r\n\r\n        unsigned int cp_count = min(NGROUPS_PER_BLOCK, count);\r\n\r\n\r\n\r\n        unsigned int len = cp_count * sizeof(*grouplist);\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n        if (copy_to_user(grouplist, group_info->blocks[i], len))\r\n\r\n\r\n\r\n            return -EFAULT;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n        grouplist += NGROUPS_PER_BLOCK;\r\n\r\n\r\n\r\n        count -= cp_count;\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    return 0;\r\n\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/* fill a group_info from a user-space array - it must be allocated already */\r\n\r\n\r\n\r\nstatic int groups_from_user(struct group_info *group_info,\r\n\r\n\r\n\r\n    gid_t __user *grouplist)\r\n\r\n\r\n\r\n{\r\n\r\n\r\n\r\n    int i;\r\n\r\n\r\n\r\n    unsigned int count = group_info->ngroups;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    for (i = 0; i < group_info->nblocks; i++) {\r\n\r\n\r\n\r\n        unsigned int cp_count = min(NGROUPS_PER_BLOCK, count);\r\n\r\n\r\n\r\n        unsigned int len = cp_count * sizeof(*grouplist);\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n        if (copy_from_user(group_info->blocks[i], grouplist, len))\r\n\r\n\r\n\r\n            return -EFAULT;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n        grouplist += NGROUPS_PER_BLOCK;\r\n\r\n\r\n\r\n        count -= cp_count;\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    return 0;\r\n\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/* a simple Shell sort */\r\n\r\n\r\n\r\nstatic void groups_sort(struct group_info *group_info)\r\n\r\n\r\n\r\n{\r\n\r\n\r\n\r\n    int base, max, stride;`;\r\n\r\nexport default mytext;\r\n"]},"metadata":{},"sourceType":"module"}